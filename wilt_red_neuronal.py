# -*- coding: utf-8 -*-
"""Wilt_RN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DhklfZAIVfPEX8kFQOjUmveY-rywZFpT

# Redes Neuronales (RN)

Base de datos: **Wilt Data Set**

Descripción:

```
Conjunto de datos de teledetección de alta resolución (Quickbird). Pequeño número de muestras de entrenamiento de árboles enfermos, gran número para otras cubiertas del suelo. Conjunto de datos de prueba a partir de una muestra aleatoria estratificada de imágenes.

class: 'w' (diseased trees), 'n' (all other land cover)
GLCM_Pan: GLCM mean texture (Pan band)
Mean_G: Mean green value
Mean_R: Mean red value
Mean_NIR: Mean NIR value
SD_Pan: Standard deviation (Pan band)
```
"""

import pandas as pd
# Extraemos la información del file csv
training = pd.read_csv("Wilt.csv")
# Detalles de la base de datos
training.info()
# Tabla con los 5 primeros datos
training.head(5)

# Aplicamos condicional:
# n (all other land cover) - 0
# w (diseased trees) - 1
training["class"] = training["class"].apply(lambda toLabel: 0 if toLabel == "n" else 1)
# Tabla con los 5 primeros datos
training.head(5)

# Asignamos las columnas a considerar a una variable
columns = ["GLCM_pan", "Mean_Green", "Mean_Red", "Mean_NIR", "SD_pan"]
# X_input representa los valores de entrada
X_input = training[list(columns)].values
# Y_Target representa los valores de salida deseadas
Y_target = training["class"].values

"""**Definimos la estructura de la red neuronal para el aprendizaje**"""

from keras.models import Sequential
from keras.layers.core import Dense

model = Sequential()
# input_dim representan los valores de entrada
# 2 capas ocultas de tamaño 16 y 1 capa de 1
model.add(Dense(16, input_dim = 5, activation = 'relu'))
model.add(Dense(16, activation = 'relu'))
model.add(Dense(1, activation = 'sigmoid'))

# binary_crossentropy ==> datos binarios
model.compile(loss='binary_crossentropy', optimizer='adam', metrics='accuracy')

# Preparamos para el proceso de entrenamiento
epocas_historial = model.fit(X_input, Y_target, epochs=1000)

# Evaluamos la precisión
score = model.evaluate(X_input, Y_target)
print("\n %s: %.2f%%" % (model.metrics_names[1],score[1]*100))

"""**Caso Prueba - Red Neuronal**"""

output = model.predict([[120.3627737,205.5,119.3953488,416.5813953,20.67631835]])
print(output) # expected output (w - 1)

output2 = model.predict([[131.3865546,185.4666667,85.46666667,419.6666667,13.33999833]])
print(output2) # expected output (n - 0)